#summary This is a short introduction on how to use PyCSP
#labels Featured

= Introduction =

PyCSP provides an API that can be used to write concurrent
applications using CSP. The API is implemented in four versions:
Threads, processes, greenlets and net. All implementations share an
almost identical API making it trivial to switch from one implementation to 
another.

  * pycsp.threads - A CSP process is implemented as an OS thread. The internal synchronization is handled by thread-locking mechanisms. This is the default implementation. Because of the Python Global Interpeter Lock, this is best suited for applications that spend most of their time in external routines.

  * pycsp.processes - A CSP process is implemented as an OS process. The internal synchronization is more complex than pycsp.threads and is built on top of the multiprocessing module available in Python 2.6. This implementation is not affected by the Global Interpreter Lock, but has some limitations on a Windows OS and generally has a larger communication overhead than the threaded version.

  * pycsp.greenlets - This uses co-routines instead of threads. Greenlets is a simple co-routine implementation that is bundled together with pylib. It provides the possibility to create 100.000 CSP processes in a single CSP network. This version is optimal for single-core architectures since it provides the fastest communication.

  * pycsp.net - A proof-of-concept net implementation of pycsp.threads. All synchronization is handled in a single process. This provides the same functionality as pycsp.threads, but adding a larger cost and a bottleneck by introducing the ChannelServerProcess. It requires Pyro (http://pyro.sourceforge.net/) for communication.




= Getting Started =

Start by fetching PyCSP from svn:

{{{
svn checkout http://pycsp.googlecode.com/svn/trunk/
{{{



