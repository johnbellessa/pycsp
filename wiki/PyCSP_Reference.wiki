#summary Documentation for all components in PyCSP

= Overview =

<wiki:toc max_depth="3" />


== Creating Processes ==
=== @process ===

    @process decorator for creating process functions

{{{
    >>> @process
    ... def P():
    ...     pass
}}}

{{{
    >>> isinstance(P(), Process)
    True
}}}

== Starting Processes ==
=== Parallel ===
 Parallel(P1, [P2, .. ,PN])

{{{
    >>> @process
    ... def P1(cout, id):
    ...     for i in range(10):
    ...         cout(id)
}}}

{{{
    >>> @process
    ... def P2(cin):
    ...     for i in range(10):
    ...         cin()
}}}

{{{
    >>> C = [Channel() for i in range(10)]
    >>> Cin = map(IN, C)
    >>> Cout = map(OUT, C)
}}}

{{{
    >>> Parallel([P1(Cout[i], i) for i in range(10)],[P2(Cin[i]) for i in range(10)])
}}}

=== Sequence ===
 Sequence(P1, [P2, .. ,PN])
    The Sequence construct returns when all given processes exit.

{{{
    >>> @process
    ... def P1(cout):
    ...     Sequence([Process(cout,i) for i in range(10)])
}}}

{{{
    >>> C = Channel()
    >>> Spawn(P1(OUT(C)))
}}}

{{{
    >>> L = []
    >>> cin = IN(C)
    >>> for i in range(10):
    ...    L.append(cin())
}}}

{{{
    >>> L
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}}}

=== Spawn ===
 Spawn(P1, [P2, .. ,PN])

{{{
    >>> @process
    ... def P1(cout, id):
    ...     for i in range(10):
    ...         cout(id)
}}}

{{{
    >>> C = Channel()
    >>> Spawn([P1(OUT(C), i) for i in range(10)])
}}}

{{{
    >>> L = []
    >>> cin = IN(C)
    >>> for i in range(100):
    ...    L.append(cin())
}}}

{{{
    >>> len(L)
    100
}}}

== Termination and Exceptions ==
=== poison ===
 Poison channel

{{{
    >>> @process
    ... def P1(cin, done):
    ...     try:
    ...         while True:
    ...             cin()
    ...     except ChannelPoisonException:
    ...         done(42)
}}}

{{{
    >>> C1, C2 = Channel(), Channel()
    >>> Spawn(P1(IN(C1), OUT(C2)))
    >>> cout = OUT(C1)
    >>> cout('Test')
}}}

{{{
    >>> poison(cout)
}}}

{{{
    >>> cin = IN(C2)
    >>> cin()
    42
}}}

=== retire ===
 Retire reader or writer, to do auto-poisoning
    When all readers or writer of a channel have retired. The channel is retired.

{{{
    >>> C = Channel()
    >>> cout1, cout2 = OUT(C), OUT(C)
    >>> retire(cout1)
}}}

{{{
    >>> Spawn(Process(cout2, 'ok'))
}}}

{{{
    >>> try:
    ...     cout1('fail')
    ... except ChannelRetireException:
    ...     True
    True
}}}

{{{
    >>> cin = IN(C)
    >>> retire(cin)
}}}

== Channels ==
 Channel class.
    Blocking or buffered communication.


{{{
    >>> @process
    ... def P1(cout):
    ...     while True:
    ...         cout('Hello World')
}}}

{{{
    >>> C = Channel()
    >>> Spawn(P1(OUT(C)))
}}}

{{{
    >>> cin = IN(C)
    >>> cin()
    'Hello World'
}}}

{{{
    >>> retire(cin)
}}}

    Buffered channels are semantically equivalent with a chain
    of forwarding processes.
{{{
    >>> B = Channel(buffer=5)
    >>> cout = OUT(B)
    >>> for i in range(5):
    ...     cout(i)
}}}

    Poison and retire are attached to final element of the buffer.
{{{
    >>> poison(cout)
}}}

{{{
    >>> @process
    ... def sink(cin, L):
    ...     while True:
    ...         L.append(cin())
}}}

{{{
    >>> L = []
    >>> Parallel(sink(IN(B), L))
    >>> L
    [0, 1, 2, 3, 4]
}}}

=== Joining to Read ===
 Join as reader
{{{
    >>> C = Channel()
    >>> isinstance(IN(C), ChannelEndRead)
    True
}}}

=== Joining to Write ===
 Join as writer
{{{
    >>> C = Channel()
    >>> isinstance(OUT(C), ChannelEndWrite)
    True
}}}

== External Choice / Choosing a Channel ==

    Alternation supports input and output guards. Guards are ChannelEnd
    or Guard objects.

    Note that alternation always performs the guard that was chosen,
    i.e. channel input or output is executed within the alternation so
    even the empty choice with an alternation execution or a choice where
    the results are simply ignored, still performs the guarded input or
    output.


{{{
    >>> L = []
}}}

{{{
    >>> @choice 
    ... def action(channel_input):
    ...     L.append(channel_input)
}}}

{{{
    >>> @process
    ... def P1(cout, n=5):
    ...     for i in range(n):
    ...         cout(i)
}}}

{{{
    >>> @process
    ... def P2(cin1, cin2, n=10):
    ...     alt = Alternation([{cin1:action(), cin2:action()}])
    ...     for i in range(n):
    ...         alt.execute()
}}}

{{{
    >>> C1, C2 = Channel(), Channel()
    >>> Parallel(P1(OUT(C1)), P1(OUT(C2)), P2(IN(C1), IN(C2)))
}}}

{{{
    >>> len(L)
    10
}}}

{{{
    >>> L.sort()
    >>> L
    [0, 0, 1, 1, 2, 2, 3, 3, 4, 4]
}}}

=== Alternation(...).select() ===

        Selects the guard.

{{{
        >>> L1,L2 = [],[]
}}}

{{{
        >>> @process
        ... def P1(cout, n=5):
        ...     for i in range(n):
        ...         cout(i)
}}}

{{{
        >>> @process
        ... def P2(cin1, cin2, n=10):
        ...     alt = Alternation([{
        ...               cin1:None,
        ...               cin2:None
        ...           }])
        ...     for i in range(n):
        ...         (g, msg) = alt.select()
        ...         if g == cin1:
        ...             L1.append(msg)
        ...         if g == cin2:
        ...             L2.append(msg)
}}}

{{{
        >>> C1, C2 = Channel(), Channel()
        >>> Parallel(P1(OUT(C1)), P1(OUT(C2)), P2(IN(C1), IN(C2)))
}}}

{{{
        >>> len(L1), len(L2)
        (5, 5)
}}}

=== Alternation(...).execute() ===

        Selects the guard and executes the attached action. Action is a function or python code passed in a string.

{{{
        >>> L1,L2 = [],[]
}}}

{{{
        >>> @process
        ... def P1(cout, n):
        ...     for i in range(n):
        ...         cout(i)
}}}

{{{
        >>> @process
        ... def P2(cin1, cin2, n):
        ...     alt = Alternation([{
        ...               cin1:"L1.append(channel_input)",
        ...               cin2:"L2.append(channel_input)"
        ...           }])
        ...     for i in range(n):
        ...         alt.execute()
}}}

{{{
        >>> C1, C2 = Channel(), Channel()
        >>> Parallel(P1(OUT(C1),n=10), P1(OUT(C2),n=5), P2(IN(C1), IN(C2), n=15))
}}}

{{{
        >>> len(L1), len(L2)
        (10, 5)
}}}

=== @choice ===

    Decorator for creating choice objets

{{{
    >>> @choice
    ... def action(channel_input=None):
    ...     print 'Hello'
}}}

{{{
    >>> from guard import Skip
    >>> Alternation([{Skip():action()}]).execute()
    Hello
}}}

== Guards ==
=== Skip ===

    Skip will try to accept a read or a write, the moment it is posted.


{{{
    >>> C = Channel()
    >>> Cin = IN(C)
    >>> (g, msg) = Alternation([{Skip():None}, {Cin:None}]).select()
}}}

{{{
    >>> isinstance(g, Skip) and msg == None
    True
}}}

=== Timeout ===

    Timeout spawns a timer thread, when posted. If removed
    before timeout, then the timer thread is cancelled.

{{{
    >>> import time
}}}

{{{
    >>> C = Channel()
    >>> Cin = IN(C)
}}}

{{{
    >>> time_start = time.time()
    >>> (g, msg) = Alternation([{Timeout(seconds=0.5):None}, {Cin:None}]).select()
    >>> time_passed = time.time() - time_start
}}}

{{{
    >>> time_passed >= 0.5
    True
}}}

{{{
    >>> time_passed < 0.6
    True
}}}

{{{
    >>> isinstance(g, Timeout) and msg == None
    True
}}}

== Specific for pycsp.greenlets: @io ==

    @io decorator for blocking io operations.
    Execution is moved to seperate threads and the current greenlet is yielded.


{{{
    >>> @io
    ... def sleep(n):
    ...     import time
    ...     time.sleep(n)
}}}

{{{
    >>> @process
    ... def P1():
    ...     sleep(0.05)
}}}

    Sleeping for 10 times 0.05 seconds, which equals roughly half a second
    in the sequential case.
{{{
    >>> time_start = time.time()
    >>> Sequence([P1() for i in range(10)])
    >>> diff = time.time() - time_start
    >>> diff >= 0.5 and diff < 0.6
    True
}}}

    In parallel, it should be close to 0.05 seconds.
{{{
    >>> time_start = time.time()
    >>> Parallel([P1() for i in range(10)])
    >>> diff = time.time() - time_start
    >>> diff >= 0.05 and diff < 0.1
    True
}}}

