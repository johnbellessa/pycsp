#summary Documentation for all components in PyCSP

= Overview =

<wiki:toc max_depth="3" />


== Creating Processes ==
=== @process ===

    @process decorator for creating process functions

{{{
    >>> @process
    ... def P():
    ...     pass

    >>> isinstance(P(), Process)
    True
}}}

== Starting Processes ==
=== Parallel ===
 Parallel(P1, [P2, .. ,PN])

{{{
    >>> @process
    ... def P1(cout, id):
    ...     for i in range(10):
    ...         cout(id)

    >>> @process
    ... def P2(cin):
    ...     for i in range(10):
    ...         cin()

    >>> C = [Channel() for i in range(10)]
    >>> Cin = map(IN, C)
    >>> Cout = map(OUT, C)

    >>> Parallel([P1(Cout[i], i) for i in range(10)],[P2(Cin[i]) for i in range(10)])

}}}
=== Sequence ===
 Sequence(P1, [P2, .. ,PN])
    The Sequence construct returns when all given processes exit.

{{{
    >>> @process
    ... def P1(cout):
    ...     Sequence([Process(cout,i) for i in range(10)])

    >>> C = Channel()
    >>> Spawn(P1(OUT(C)))

    >>> L = []
    >>> cin = IN(C)
    >>> for i in range(10):
    ...    L.append(cin())

    >>> L
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}}}

=== Spawn ===
 Spawn(P1, [P2, .. ,PN])

{{{
    >>> @process
    ... def P1(cout, id):
    ...     for i in range(10):
    ...         cout(id)

    >>> C = Channel()
    >>> Spawn([P1(OUT(C), i) for i in range(10)])

    >>> L = []
    >>> cin = IN(C)
    >>> for i in range(100):
    ...    L.append(cin())

    >>> len(L)
    100
}}}

== Termination and Exceptions ==
=== poison ===
 Poison channel

{{{
    >>> @process
    ... def P1(cin, done):
    ...     try:
    ...         while True:
    ...             cin()
    ...     except ChannelPoisonException:
    ...         done(42)

    >>> C1, C2 = Channel(), Channel()
    >>> Spawn(P1(IN(C1), OUT(C2)))
    >>> cout = OUT(C1)
    >>> cout('Test')

    >>> poison(cout)

    >>> cin = IN(C2)
    >>> cin()
    42
}}}

=== retire ===
 Retire reader or writer, to do auto-poisoning
    When all readers or writer of a channel have retired. The channel is retired.

{{{
    >>> C = Channel()
    >>> cout1, cout2 = OUT(C), OUT(C)
    >>> retire(cout1)

    >>> Spawn(Process(cout2, 'ok'))

    >>> try:
    ...     cout1('fail')
    ... except ChannelRetireException:
    ...     True
    True
}}}

{{{
    >>> cin = IN(C)
    >>> retire(cin)

}}}
== Channels ==
 Channel class. Blocking communication


{{{
    >>> @process
    ... def P1(cout):
    ...     while True:
    ...         cout('Hello World')

    >>> C = Channel()
    >>> Spawn(P1(OUT(C)))

    >>> cin = IN(C)
    >>> cin()
    'Hello World'
}}}

{{{
    >>> retire(cin)

}}}
== Joining to Read ==
 Join as reader
{{{
    >>> C = Channel()
    >>> isinstance(IN(C), ChannelEndRead)
    True
}}}

== Joining to Write ==
 Join as writer
{{{
    >>> C = Channel()
    >>> isinstance(OUT(C), ChannelEndWrite)
    True
}}}

== External Choice / Choosing a Channel ==
=== Alternation ===

    Alternation supports input and output guards. Guards are ChannelEnd
    or Guard objects.

    Note that alternation always performs the guard that was chosen,
    i.e. channel input or output is executed within the alternation so
    even the empty choice with an alternation execution or a choice where
    the results are simply ignored, still performs the guarded input or
    output.


{{{
    >>> L = []

    >>> @choice 
    ... def action(__channel_input):
    ...     L.append(__channel_input)

    >>> @process
    ... def P1(cout, n=5):
    ...     for i in range(n):
    ...         cout(i)

    >>> @process
    ... def P2(cin1, cin2, n=10):
    ...     alt = Alternation([{cin1:action(), cin2:action()}])
    ...     for i in range(n):
    ...         alt.execute()

    >>> C1, C2 = Channel(), Channel()
    >>> Parallel(P1(OUT(C1)), P1(OUT(C2)), P2(IN(C1), IN(C2)))

    >>> len(L)
    10
}}}

{{{
    >>> L.sort()
    >>> L
    [0, 0, 1, 1, 2, 2, 3, 3, 4, 4]
}}}

=== @choice ===

    Decorator for creating choice objets

{{{
    >>> @choice
    ... def action(__channel_input=None):
    ...     print 'Hello'

    >>> from guard import Skip
    >>> Alternation([{Skip():action()}]).execute()
    Hello
}}}

== Guards ==
=== Skip ===

    Skip will try to accept a read or a write, the moment it is posted.


{{{
    >>> C = Channel()
    >>> Cin = IN(C)
    >>> (g, msg) = Alternation([{Skip():None}, {Cin:None}]).select()

    >>> isinstance(g, Skip) and msg == None
    True
}}}

=== Timeout ===

    Timeout spawns a timer thread, when posted. If removed
    before timeout, then the timer thread is cancelled.

{{{
    >>> import time

    >>> C = Channel()
    >>> Cin = IN(C)

    >>> time_start = time.time()
    >>> (g, msg) = Alternation([{Timeout(seconds=0.5):None}, {Cin:None}]).select()
    >>> time_passed = time.time() - time_start

    >>> time_passed >= 0.5
    True
}}}

{{{
    >>> time_passed < 0.6
    True
}}}

{{{
    >>> isinstance(g, Timeout) and msg == None
    True
}}}

