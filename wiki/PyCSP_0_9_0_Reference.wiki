#summary Documentation for all components in PyCSP ver. 0.9.0 (incomplete)


<wiki:toc max_depth="2" />
=<pre>@process</pre>=
<pre>
Help on function process in module pycsp.parallel.process:

process(func)
    @process decorator for making a function into a CSP Process factory.
    Each generated CSP process is implemented as a single OS thread.
    
    Usage:
      >>> @process
      >>> def filter(dataIn, dataOut, tag, debug=False):
      >>>   pass # perform filtering
      >>>
      >>> P = filter(A.reader(), B.writer(), "42", debug=True)
    
    The CSP Process factory returned by the @process decorator:
      func(*args, **kwargs)

</pre>
=<pre>Process</pre>=
<pre>
Help on class Process in module pycsp.parallel.process:

class Process(threading.Thread)
 |  CSP process implemented as a single OS thread.
 |  
 |  It is recommended to use the @process decorator, to create Process instances.
 |  See help(pycsp.process)
 |  
 |  Usage:
 |    >>> def filter(dataIn, dataOut, tag, debug=False):
 |    >>>   pass # perform filtering
 |    >>>
 |    >>> P = Process(filter, A.reader(), B.writer(), "42", debug=True) 
 |  
 |  Process(func, *args, **kwargs)
 |  func
 |    The function object to wrap and execute in the body of the process.
 |  args and kwargs are passed directly to the execution of the function object.
 |  
 |  Public variables:
 |    Process.name       Unique name to identify the process
 |  
 |  Method resolution order:
 |      Process
 |      threading.Thread
 |      threading._Verbose
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, fn, *args, **kwargs)
 |  
 |  __mul__(self, multiplier)
 |      # syntactic sugar:  Process() * 2 == [Process<1>,Process<2>]
 |  
 |  __rmul__(self, multiplier)
 |      # syntactic sugar:  2 * Process() == [Process<1>,Process<2>]
 |  
 |  run(self)
 |  
 |  wait(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from threading.Thread:
 |  
 |  __repr__(self)
 |  
 |  getName(self)
 |  
 |  isAlive(self)
 |  
 |  isDaemon(self)
 |  
 |  is_alive = isAlive(self)
 |  
 |  join(self, timeout=None)
 |  
 |  setDaemon(self, daemonic)
 |  
 |  setName(self, name)
 |  
 |  start(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from threading.Thread:
 |  
 |  daemon
 |  
 |  ident
 |  
 |  name
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from threading._Verbose:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

</pre>
=<pre>Channel</pre>=
<pre>
Help on class Channel in module pycsp.parallel.channel:

class Channel(__builtin__.object)
 |  Any-2-any channel for communication between both local and remote processes.
 |  
 |  To communicate on this channel, channel ends must be requested using the .reader/.writer methods.
 |  
 |  Usage:
 |    >>> A = Channel("A")
 |    >>> cout = A.writer()
 |    >>> cout("Hello World")
 |  
 |  A channel is registered at the Python interpreter level and hosted in the interpreter where it
 |  was created.
 |  
 |  Retrieving the address and name of a channel:
 |  >>> print(A.address)
 |  ('10.11.105.254', 33703)
 |  >>> print(A.name)
 |  A
 |  
 |  Channel(name=None, buffer=0, connect=None):
 |  name
 |    is a string used for identifying the Channel and must be unique for every Channel instance.
 |    The name is limited to maximum 32 characters. If name=None then a unique name is generated.
 |  buffer
 |    The channel may be buffered by configuring a buffer of size <buffer>.
 |    buffer=3 will create a channel which can contain three elements, before blocking send.
 |  connect
 |    If provided with (host, port), the channel will not create a host, but instead try to connect
 |    to (host, port) and register at the channel here.
 |    A name must be provided when connect is set.
 |  
 |  Public variables:
 |    Channel.address    (host, port) where the channel is hosted
 |    Channel.name       name to identify the hosted channel
 |  
 |  Methods defined here:
 |  
 |  __init__(self, name=None, buffer=0, connect=None)
 |      # Constructor
 |  
 |  __mul__(self, multiplier)
 |      # syntactic sugar: Channel() * N
 |  
 |  __neg__(self)
 |      # syntactic sugar: cout = -chan
 |  
 |  __pos__(self)
 |      # syntactic sugar: cin = +chan
 |  
 |  __rmul__(self, multiplier)
 |      # syntactic sugar: N * Channel()
 |  
 |  disconnect(self)
 |      Explicit close is only relevant for channel references
 |      connected to remote channels
 |      
 |      It can be used to make an early close, to allow another interpreter
 |      hosting the channel home, to quit. This is especially useful when
 |      used in a server - client setting, where the client has provied a 
 |      reply channel and desires to disconnect after having received the reply.
 |      
 |      The channel reference will automatically open and reconnect if it is used after a close.
 |  
 |  reader(self)
 |      Create and return a receiving end of the channel
 |      
 |      Returns:
 |        ChannelEndRead object
 |      
 |      Usage:
 |        >>> C = Channel()
 |        >>> cin = C.reader()
 |        >>> print( cin() ) # Read
 |  
 |  writer(self)
 |      Create and return a writing end of the channel
 |      
 |      Returns:
 |        ChannelEndWrite object
 |      
 |      Usage:
 |        >>> C = Channel()
 |        >>> cout = C.writer()
 |        >>> cout("Hello reader")
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

</pre>
=<pre>ChannelEndRead</pre>=
<pre>
Help on instance of ChannelEndRead in module pycsp.parallel.channel:

class ChannelEndRead(ChannelEnd)
 |  The reading end of a channel. 
 |  
 |  Usage:
 |    >>> val = reading_end()
 |  
 |  Throws:
 |    ChannelPoisonException()
 |    ChannelRetireException()
 |  
 |  If the poison and retire exceptions are not caught explicitly they will automatically be
 |  propagated to all other known channelends provided to the process in the argument list.
 |  
 |  Methods defined here:
 |  
 |  __call__(self)
 |  
 |  __init__(self, channel)
 |  
 |  __repr__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ChannelEnd:
 |  
 |  __getstate__(self)
 |      Enables channel end mobility
 |  
 |  __setstate__(self, dict)
 |      Enables channel end mobility
 |  
 |  disconnect(self)
 |      Explicit close is only relevant for mobile channel ends to invoke an
 |      early close.
 |      
 |      The reason for an early close is to allow another interpreter
 |      hosting the channel home, to quit. This is especially useful when
 |      used in a server/client setting, where the client has provided a 
 |      reply channel and desires to disconnect after having received the reply.
 |      
 |      The mobile channel end reference will automatically open and reconnect if
 |      it is used after a close.
 |  
 |  isReader(self)
 |      Returns True for ChannelEndRead object
 |  
 |  isWriter(self)
 |      Returns True for ChannelEndWrite object
 |  
 |  poison(self)
 |      Poison channel end
 |      
 |      When a channel end is poisoned, the channel is set into a poisoned state where
 |      after all actions on the channel will invoke a ChannelPoisonException which
 |      is propagated through the PyCSP network to shutdown all processes unless
 |      caugth by the user with a try/except clause.
 |      
 |      Notice that poisoning may cause race conditions, when terminating multiple concurrent processes.
 |      See retire for an improved shutdown method.
 |  
 |  retire(self)
 |      Retire channel end
 |      
 |      When a channel end is retired, the channel is signaled that a channel end
 |      has now left the channel. When the set of all reading or writing channel ends is set
 |      to none, then the channel enters a retired state whereafter
 |      all actions on the channel will invoke a ChannelRetireException which
 |      is propagated through the PyCSP network to nicely shutdown all processes unless
 |      caugth by the user with a try/except clause.
 |      
 |      Retiring is an improved version of poisoning, which avoids the race condition issue
 |      when terminating multiple concurrent processes.

</pre>
=<pre>ChannelEndWrite</pre>=
<pre>
Help on instance of ChannelEndWrite in module pycsp.parallel.channel:

class ChannelEndWrite(ChannelEnd)
 |  Methods defined here:
 |  
 |  __call__(self, msg)
 |  
 |  __init__(self, channel)
 |  
 |  __repr__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ChannelEnd:
 |  
 |  __getstate__(self)
 |      Enables channel end mobility
 |  
 |  __setstate__(self, dict)
 |      Enables channel end mobility
 |  
 |  disconnect(self)
 |      Explicit close is only relevant for mobile channel ends to invoke an
 |      early close.
 |      
 |      The reason for an early close is to allow another interpreter
 |      hosting the channel home, to quit. This is especially useful when
 |      used in a server/client setting, where the client has provided a 
 |      reply channel and desires to disconnect after having received the reply.
 |      
 |      The mobile channel end reference will automatically open and reconnect if
 |      it is used after a close.
 |  
 |  isReader(self)
 |      Returns True for ChannelEndRead object
 |  
 |  isWriter(self)
 |      Returns True for ChannelEndWrite object
 |  
 |  poison(self)
 |      Poison channel end
 |      
 |      When a channel end is poisoned, the channel is set into a poisoned state where
 |      after all actions on the channel will invoke a ChannelPoisonException which
 |      is propagated through the PyCSP network to shutdown all processes unless
 |      caugth by the user with a try/except clause.
 |      
 |      Notice that poisoning may cause race conditions, when terminating multiple concurrent processes.
 |      See retire for an improved shutdown method.
 |  
 |  retire(self)
 |      Retire channel end
 |      
 |      When a channel end is retired, the channel is signaled that a channel end
 |      has now left the channel. When the set of all reading or writing channel ends is set
 |      to none, then the channel enters a retired state whereafter
 |      all actions on the channel will invoke a ChannelRetireException which
 |      is propagated through the PyCSP network to nicely shutdown all processes unless
 |      caugth by the user with a try/except clause.
 |      
 |      Retiring is an improved version of poisoning, which avoids the race condition issue
 |      when terminating multiple concurrent processes.

</pre>
=<pre>retire</pre>=
<pre>
Help on function retire in module pycsp.parallel.channel:

retire(*list_of_channelEnds)
    Retire(C1, [C2, .. , CN])
    
    Retire channel ends
    
    When a channel end is retired, the channel is signaled that a channel end
    has now left the channel. When the set of all reading or writing channel ends is set
    to none, then the channel enters a retired state whereafter
    all actions on the channel will invoke a ChannelRetireException which
    is propagated through the PyCSP network to nicely shutdown all processes unless
    caugth by the user with a try/except clause.
    
    Retiring is an improved version of poisoning, which avoids the race condition issue
    when terminating multiple concurrent processes.
    
    Usage:
    >>> retire(cin0)
    >>> retire(cin0, cin1, cout0)
    >>> retire(cinList)

</pre>
=<pre>poison</pre>=
<pre>
Help on function poison in module pycsp.parallel.channel:

poison(*list_of_channelEnds)
    Poison(C1, [C2, .. , CN])
    
    Poison channel ends
    
    When a channel end is poisoned, the channel is set into a poisoned state where
    after all actions on the channel will invoke a ChannelPoisonException which
    is propagated through the PyCSP network to shutdown all processes unless
    caugth by the user with a try/except clause.
    
    Notice that poisoning may cause race conditions, when terminating multiple concurrent processes.
    See retire for an improved shutdown method.
    
    Usage:
    >>> poison(cin0)
    >>> poison(cin0, cin1, cout0)
    >>> poison(cinList)

</pre>
=<pre>Parallel</pre>=
<pre>
Help on function Parallel in module pycsp.parallel.process:

Parallel(*plist)
    Parallel(P1, [P2, .. ,PN])
    
    Performs concurrent synchronous execution of the supplied CSP processes. 
    
    Blocks until all processes have exited.
    
    Usage:
      >>> @process
      ... def P1(cout):
      ...     for i in range(10):
      ...         cout(i)
      ...     retire(cout)
    
      >>> @process
      ... def P2(cin):
      ...     while True:
      ...         cin()
    
      >>> C = Channel()  
      >>> Parallel(P1(C.writer()), P2(C.reader()))

</pre>
=<pre>Spawn</pre>=
<pre>
Help on function Spawn in module pycsp.parallel.process:

Spawn(*plist)
    Spawn(P1, [P2, .. ,PN])
    
    Performs concurrent asynchronous execution of the supplied CSP processes. 
    
    Usage:
      >>> @process
      ... def P1(cout):
      ...     for i in range(10):
      ...         cout(i)
      ...     retire(cout)
    
      >>> C = Channel()  
      >>> Parallel(P1(C.writer()))
    
      >>> cin = C.reader()
      ... try:
      ...     while True:
      ...         cin()

</pre>
=<pre>Sequence</pre>=
<pre>
Help on function Sequence in module pycsp.parallel.process:

Sequence(*plist)
    Sequence(P1, [P2, .. ,PN])
    
    Performs synchronous execution of the supplied CSP processes. 
    
    The supplied processes are executed in order.
    
    Blocks until the last process has exited.
    
    Usage:
      >>> @process
      ... def P1(id):
      ...     print(id)
    
      >>> L = [P1(i) for i in range(10)]
      >>> Sequence(L)

</pre>
=<pre>current_process_id</pre>=
<pre>
Help on function current_process_id in module pycsp.parallel.process:

current_process_id()
    Returns the id of the executing CSP process.

</pre>
=<pre>shutdown</pre>=
<pre>
Help on function shutdown in module pycsp.parallel.process:

shutdown()
    TODO!

</pre>