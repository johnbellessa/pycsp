#summary Tutorial on how to get started with PyCSP (page 2)
#labels Tutorial
#sidebar TutorialList

= Multiple readers and writers =

Channels may have multiple readers or writers. It is not only legal, but also a very useful feature of CSP. The consistency lies in the model, which dictates that a writer is blocked until his message is received by exactly one reader.

{{{
@process
def source(chan_out):
    for i in range(10):
        chan_out("Hello world (%d)\n" % (i))
    retire(chan_out)
    
@process
def sink(chan_in):
    while True:
        sys.stdout.write(chan_in())

chan = Channel()
Parallel(
    5 * source(chan.writer()),
    5 * sink(chan.reader())
)
}}}

= Buffered Channels =

Channels in PyCSP are any-to-any and can be buffered.  To enable a buffer on a channel.

{{{
BufferC = Channel('A', buffer=3)
cout = BufferC.writer()
cin = BufferC.reader()
}}}

This channel has a buffer size of 3 and is semantically equivalent to the following network.

{{{
@process
def BufferP(cin,cout):
  while True:
    cout(cin())

BufferC = Channel('A_buf')*4
for i in range(3):
  Spawn(
    BufferP(
      BufferC[i].reader(), BufferC[i+1].writer()
    )
  )
cout = BufferC[0].writer()
cin = BufferC[4].reader()
}}}

When a channel is buffered, it seems that a writer is now allowed to deliver a message, without the message has been received by one reader. This is not true, which is apparent when we look at the network above. Here a BufferP process actually reads the message for every message delivered. When no BufferP process is able to read, the writer trying to write to the buffered channel is blocked.

The use of buffered channels can be tricky, when used as output guards with AltSelect (external choice). The reason is that buffered channels are ready to receive messages until the buffer is full. To avoid starving other guards, buffered channels should be used as the last elements in the AltSelect or alternatively the FairSelect may used to balance the guards.

= External Choice (AltSelect or FairSelect) =

The external choice selects a single guard from a set of guards. The current guard types are:

{{{
* InputGuard(cin, action=[optional])
* OutputGuard(cout, msg=<message>, action=[optional])
* TimerGuard(seconds=<s>, action=[optional])
* SkipGuard(action=[optional])
}}}

where
{{{
cin = <chan>.reader()
cout = <chan>.writer()
}}}

AltSelect will perform a prioritized selection between the given guards. To select from multiple channels:

{{{
@process
def P1(cout, val):
  for i in range(5):
    cout(val)

A = Channel() * 2

@process
def P2(cin1, cin2):
  for i in range(10):
    g, msg = AltSelect(
      InputGuard(cin1),
      InputGuard(cin2)
    )
    if g == cin1:
      print 'Received',msg,'from chan1'
    else:
      print 'Received',msg,'from chan2'


Parallel(
  P1(A[0].writer(), 'Chan1'),
  P1(A[1].writer(), 'Chan2'),
  P2(A[0].reader(), A[1].reader())
)
}}}

Output:
{{{
Received Chan1 from chan1
Received Chan1 from chan1
Received Chan1 from chan1
Received Chan2 from chan2
Received Chan1 from chan1
Received Chan1 from chan1
Received Chan2 from chan2
Received Chan2 from chan2
Received Chan2 from chan2
Received Chan2 from chan2
}}}

