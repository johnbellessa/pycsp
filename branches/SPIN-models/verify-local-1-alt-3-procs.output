
(Spin Version 5.2.5 -- 17 April 2010)
	+ Partial Order Reduction
	+ Compression

Full statespace search for:
	never claim         	- (none specified)
	assertion violations	+
	cycle checks       	- (disabled by -DSAFETY)
	invalid end states	+

State-vector 116 byte, depth reached 267, errors: 0
   222543 states, stored
   198403 states, matched
   420946 transitions (= stored+matched)
        0 atomic steps
hash conflicts:     26027 (resolved)

Stats on memory usage (in Megabytes):
   30.562	equivalent memory usage for states (stored*(State-vector + overhead))
    9.464	actual memory usage for states (compression: 30.97%)
         	state-vector as stored = 17 byte + 28 byte overhead
    4.000	memory used for hash table (-w19)
    0.458	memory used for DFS stack (-m10000)
   13.662	total actual memory usage

nr of templates: [ globals chans procs ]
collapse counts: [ 3072 135 108 756 4 ]
unreached in proctype PR
	line 40, state 20, "((proc[r_pid].lock==0))"
	line 46, state 58, "proc[w_pid].lock = 0"
	line 149, state 126, "(1)"
	(3 of 140 states)
unreached in proctype PW
	line 40, state 30, "((proc[w_pid].lock==0))"
	line 46, state 64, "proc[r_pid].lock = 0"
	line 178, state 120, "(1)"
	(3 of 133 states)
unreached in proctype ALT
	line 40, state 32, "((proc[w_pid].lock==0))"
	line 46, state 66, "proc[r_pid].lock = 0"
	line 163, state 93, "ch[0].wqueue[ch[0].wlen].id = _pid"
	line 164, state 94, "ch[0].wqueue[ch[0].wlen].msg = 255"
	line 164, state 95, "ch[0].wlen = (ch[0].wlen+1)"
	line 71, state 98, "printf('Matching R:%d procs to W:%d procs\n',ch[0].rlen,ch[0].wlen)"
	line 74, state 100, "w = 0"
	line 90, state 103, "w_pid = ch[0].wqueue[w].id"
	line 40, state 108, "((proc[r_pid].lock==0))"
	line 40, state 112, "((proc[w_pid].lock==0))"
	line 40, state 118, "((proc[w_pid].lock==0))"
	line 40, state 122, "((proc[r_pid].lock==0))"
	line 101, state 127, "printf('Success for R:%d and W:%d\n',r_pid,w_pid)"
	line 102, state 128, "proc[r_pid].state = SUCCESS"
	line 103, state 129, "proc[w_pid].state = SUCCESS"
	line 105, state 130, "ch[0].rqueue[r].msg = ch[0].wqueue[w].msg"
	line 103, state 131, "ch[0].wqueue[w].msg = 255"
	line 103, state 132, "proc[r_pid].result_ch = 0"
	line 103, state 133, "proc[w_pid].result_ch = 0"
	line 66, state 135, "proc[r_pid].waitX = 1"
	line 66, state 137, "proc[w_pid].waitX = 1"
	line 104, state 138, "r = 4"
	line 46, state 146, "proc[w_pid].lock = 0"
	line 46, state 152, "proc[r_pid].lock = 0"
	line 89, state 157, "r_pid = ch[0].rqueue[r].id"
	line 73, state 167, "((r<ch[0].rlen))"
	line 73, state 167, "else"
	line 81, state 170, "printf('debug: R:%d, W:%d\n',ch[0].rlen,ch[0].wlen)"
	line 70, state 171, "w = 0"
	line 165, state 172, "ch[0].lock = 0"
	line 165, state 173, "printf('Posted write\n')"
	line 162, state 174, "((ch[0].lock==0))"
	line 130, state 181, "ch[1].rqueue[ch[1].rlen].id = _pid"
	line 131, state 182, "ch[1].rqueue[ch[1].rlen].msg = 255"
	line 131, state 183, "ch[1].rlen = (ch[1].rlen+1)"
	line 71, state 186, "printf('Matching R:%d procs to W:%d procs\n',ch[1].rlen,ch[1].wlen)"
	line 74, state 188, "w = 0"
	line 90, state 191, "w_pid = ch[1].wqueue[w].id"
	line 40, state 196, "((proc[r_pid].lock==0))"
	line 40, state 200, "((proc[w_pid].lock==0))"
	line 40, state 206, "((proc[w_pid].lock==0))"
	line 40, state 210, "((proc[r_pid].lock==0))"
	line 101, state 215, "printf('Success for R:%d and W:%d\n',r_pid,w_pid)"
	line 102, state 216, "proc[r_pid].state = SUCCESS"
	line 103, state 217, "proc[w_pid].state = SUCCESS"
	line 105, state 218, "ch[1].rqueue[r].msg = ch[1].wqueue[w].msg"
	line 103, state 219, "ch[1].wqueue[w].msg = 255"
	line 103, state 220, "proc[r_pid].result_ch = 1"
	line 103, state 221, "proc[w_pid].result_ch = 1"
	line 66, state 223, "proc[r_pid].waitX = 1"
	line 66, state 225, "proc[w_pid].waitX = 1"
	line 104, state 226, "r = 4"
	line 46, state 234, "proc[w_pid].lock = 0"
	line 46, state 240, "proc[r_pid].lock = 0"
	line 89, state 245, "r_pid = ch[1].rqueue[r].id"
	line 73, state 255, "((r<ch[1].rlen))"
	line 73, state 255, "else"
	line 81, state 258, "printf('debug: R:%d, W:%d\n',ch[1].rlen,ch[1].wlen)"
	line 70, state 259, "w = 0"
	line 132, state 260, "ch[1].lock = 0"
	line 132, state 261, "printf('Posted read\n')"
	line 129, state 262, "((ch[1].lock==0))"
	line 40, state 282, "((proc[r_pid].lock==0))"
	line 46, state 320, "proc[w_pid].lock = 0"
	line 149, state 391, "(1)"
	line 173, state 406, "i = 0"
	line 177, state 409, "ch[0].wlen = (ch[0].wlen-1)"
	line 178, state 410, "ch[0].wqueue[i].id = ch[0].wqueue[ch[0].wlen].id"
	line 179, state 411, "ch[0].wqueue[i].msg = ch[0].wqueue[ch[0].wlen].msg"
	line 178, state 413, "(1)"
	line 176, state 414, "((ch[0].wqueue[i].id==_pid))"
	line 176, state 414, "else"
	line 174, state 419, "((i<ch[0].wlen))"
	line 174, state 419, "else"
	line 183, state 422, "ch[0].lock = 0"
	line 172, state 423, "((ch[0].lock==0))"
	line 141, state 430, "i = 0"
	line 146, state 434, "result_msg = ch[1].rqueue[i].msg"
	line 148, state 439, "ch[1].rlen = (ch[1].rlen-1)"
	line 149, state 440, "ch[1].rqueue[i].id = ch[1].rqueue[ch[1].rlen].id"
	line 150, state 441, "ch[1].rqueue[i].msg = ch[1].rqueue[ch[1].rlen].msg"
	line 149, state 443, "(1)"
	line 144, state 444, "((ch[1].rqueue[i].id==_pid))"
	line 144, state 444, "else"
	line 142, state 449, "((i<ch[1].rlen))"
	line 142, state 449, "else"
	line 154, state 452, "ch[1].lock = 0"
	line 140, state 453, "((ch[1].lock==0))"
	line 178, state 465, "(1)"
	line 40, state 512, "((proc[w_pid].lock==0))"
	line 46, state 546, "proc[r_pid].lock = 0"
	line 163, state 573, "ch[0].wqueue[ch[0].wlen].id = _pid"
	line 164, state 574, "ch[0].wqueue[ch[0].wlen].msg = 255"
	line 164, state 575, "ch[0].wlen = (ch[0].wlen+1)"
	line 71, state 578, "printf('Matching R:%d procs to W:%d procs\n',ch[0].rlen,ch[0].wlen)"
	line 74, state 580, "w = 0"
	line 90, state 583, "w_pid = ch[0].wqueue[w].id"
	line 40, state 588, "((proc[r_pid].lock==0))"
	line 40, state 592, "((proc[w_pid].lock==0))"
	line 40, state 598, "((proc[w_pid].lock==0))"
	line 40, state 602, "((proc[r_pid].lock==0))"
	line 101, state 607, "printf('Success for R:%d and W:%d\n',r_pid,w_pid)"
	line 102, state 608, "proc[r_pid].state = SUCCESS"
	line 103, state 609, "proc[w_pid].state = SUCCESS"
	line 105, state 610, "ch[0].rqueue[r].msg = ch[0].wqueue[w].msg"
	line 103, state 611, "ch[0].wqueue[w].msg = 255"
	line 103, state 612, "proc[r_pid].result_ch = 0"
	line 103, state 613, "proc[w_pid].result_ch = 0"
	line 66, state 615, "proc[r_pid].waitX = 1"
	line 66, state 617, "proc[w_pid].waitX = 1"
	line 104, state 618, "r = 4"
	line 46, state 626, "proc[w_pid].lock = 0"
	line 46, state 632, "proc[r_pid].lock = 0"
	line 89, state 637, "r_pid = ch[0].rqueue[r].id"
	line 73, state 647, "((r<ch[0].rlen))"
	line 73, state 647, "else"
	line 81, state 650, "printf('debug: R:%d, W:%d\n',ch[0].rlen,ch[0].wlen)"
	line 70, state 651, "w = 0"
	line 165, state 652, "ch[0].lock = 0"
	line 165, state 653, "printf('Posted write\n')"
	line 162, state 654, "((ch[0].lock==0))"
	line 130, state 661, "ch[1].rqueue[ch[1].rlen].id = _pid"
	line 131, state 662, "ch[1].rqueue[ch[1].rlen].msg = 255"
	line 131, state 663, "ch[1].rlen = (ch[1].rlen+1)"
	line 71, state 666, "printf('Matching R:%d procs to W:%d procs\n',ch[1].rlen,ch[1].wlen)"
	line 74, state 668, "w = 0"
	line 90, state 671, "w_pid = ch[1].wqueue[w].id"
	line 40, state 676, "((proc[r_pid].lock==0))"
	line 40, state 680, "((proc[w_pid].lock==0))"
	line 40, state 686, "((proc[w_pid].lock==0))"
	line 40, state 690, "((proc[r_pid].lock==0))"
	line 101, state 695, "printf('Success for R:%d and W:%d\n',r_pid,w_pid)"
	line 102, state 696, "proc[r_pid].state = SUCCESS"
	line 103, state 697, "proc[w_pid].state = SUCCESS"
	line 105, state 698, "ch[1].rqueue[r].msg = ch[1].wqueue[w].msg"
	line 103, state 699, "ch[1].wqueue[w].msg = 255"
	line 103, state 700, "proc[r_pid].result_ch = 1"
	line 103, state 701, "proc[w_pid].result_ch = 1"
	line 66, state 703, "proc[r_pid].waitX = 1"
	line 66, state 705, "proc[w_pid].waitX = 1"
	line 104, state 706, "r = 4"
	line 46, state 714, "proc[w_pid].lock = 0"
	line 46, state 720, "proc[r_pid].lock = 0"
	line 89, state 725, "r_pid = ch[1].rqueue[r].id"
	line 73, state 735, "((r<ch[1].rlen))"
	line 73, state 735, "else"
	line 81, state 738, "printf('debug: R:%d, W:%d\n',ch[1].rlen,ch[1].wlen)"
	line 70, state 739, "w = 0"
	line 132, state 740, "ch[1].lock = 0"
	line 132, state 741, "printf('Posted read\n')"
	line 129, state 742, "((ch[1].lock==0))"
	line 40, state 762, "((proc[r_pid].lock==0))"
	line 46, state 800, "proc[w_pid].lock = 0"
	line 149, state 871, "(1)"
	line 173, state 886, "i = 0"
	line 177, state 889, "ch[0].wlen = (ch[0].wlen-1)"
	line 178, state 890, "ch[0].wqueue[i].id = ch[0].wqueue[ch[0].wlen].id"
	line 179, state 891, "ch[0].wqueue[i].msg = ch[0].wqueue[ch[0].wlen].msg"
	line 178, state 893, "(1)"
	line 176, state 894, "((ch[0].wqueue[i].id==_pid))"
	line 176, state 894, "else"
	line 174, state 899, "((i<ch[0].wlen))"
	line 174, state 899, "else"
	line 183, state 902, "ch[0].lock = 0"
	line 172, state 903, "((ch[0].lock==0))"
	line 141, state 910, "i = 0"
	line 146, state 914, "result_msg = ch[1].rqueue[i].msg"
	line 148, state 919, "ch[1].rlen = (ch[1].rlen-1)"
	line 149, state 920, "ch[1].rqueue[i].id = ch[1].rqueue[ch[1].rlen].id"
	line 150, state 921, "ch[1].rqueue[i].msg = ch[1].rqueue[ch[1].rlen].msg"
	line 149, state 923, "(1)"
	line 144, state 924, "((ch[1].rqueue[i].id==_pid))"
	line 144, state 924, "else"
	line 142, state 929, "((i<ch[1].rlen))"
	line 142, state 929, "else"
	line 154, state 932, "ch[1].lock = 0"
	line 140, state 933, "((ch[1].lock==0))"
	line 178, state 945, "(1)"
	(166 of 961 states)
unreached in proctype :init:
	(0 of 4 states)

pan: elapsed time 0.4 seconds
pan: rate  556357.5 states/second
