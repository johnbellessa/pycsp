
(Spin Version 5.2.5 -- 17 April 2010)
	+ Partial Order Reduction
	+ Compression

Full statespace search for:
	never claim         	- (none specified)
	assertion violations	+
	cycle checks       	- (disabled by -DSAFETY)
	invalid end states	+

State-vector 92 byte, depth reached 163, errors: 0
     7280 states, stored
     3548 states, matched
    10828 transitions (= stored+matched)
        0 atomic steps
hash conflicts:        14 (resolved)

Stats on memory usage (in Megabytes):
    0.833	equivalent memory usage for states (stored*(State-vector + overhead))
    1.091	actual memory usage for states (unsuccessful compression: 130.99%)
         	state-vector as stored = 129 byte + 28 byte overhead
    4.000	memory used for hash table (-w19)
    0.458	memory used for DFS stack (-m10000)
    5.258	total actual memory usage

nr of templates: [ globals chans procs ]
collapse counts: [ 433 259 258 3 ]
unreached in proctype ALTRW
	line 40, state 32, "((proc[w_pid].lock==0))"
	line 46, state 66, "proc[r_pid].lock = 0"
	line 164, state 93, "ch[0].wqueue[ch[0].wlen].id = _pid"
	line 165, state 94, "ch[0].wqueue[ch[0].wlen].msg = 255"
	line 165, state 95, "ch[0].wlen = (ch[0].wlen+1)"
	line 71, state 98, "printf('Matching R:%d procs to W:%d procs\n',ch[0].rlen,ch[0].wlen)"
	line 74, state 100, "w = 0"
	line 90, state 103, "w_pid = ch[0].wqueue[w].id"
	line 40, state 108, "((proc[r_pid].lock==0))"
	line 40, state 112, "((proc[w_pid].lock==0))"
	line 40, state 118, "((proc[w_pid].lock==0))"
	line 40, state 122, "((proc[r_pid].lock==0))"
	line 101, state 127, "printf('Success for R:%d and W:%d\n',r_pid,w_pid)"
	line 102, state 128, "proc[r_pid].state = SUCCESS"
	line 103, state 129, "proc[w_pid].state = SUCCESS"
	line 105, state 130, "ch[0].rqueue[r].msg = ch[0].wqueue[w].msg"
	line 103, state 131, "ch[0].wqueue[w].msg = 255"
	line 103, state 132, "proc[r_pid].result_ch = 0"
	line 103, state 133, "proc[w_pid].result_ch = 0"
	line 66, state 135, "proc[r_pid].waitX = 1"
	line 66, state 137, "proc[w_pid].waitX = 1"
	line 104, state 138, "r = 3"
	line 46, state 146, "proc[w_pid].lock = 0"
	line 46, state 152, "proc[r_pid].lock = 0"
	line 89, state 157, "r_pid = ch[0].rqueue[r].id"
	line 73, state 167, "((r<ch[0].rlen))"
	line 73, state 167, "else"
	line 81, state 170, "printf('debug: R:%d, W:%d\n',ch[0].rlen,ch[0].wlen)"
	line 70, state 171, "w = 0"
	line 166, state 172, "ch[0].lock = 0"
	line 166, state 173, "printf('Posted write\n')"
	line 163, state 174, "((ch[0].lock==0))"
	line 130, state 181, "ch[1].rqueue[ch[1].rlen].id = _pid"
	line 131, state 182, "ch[1].rqueue[ch[1].rlen].msg = 255"
	line 131, state 183, "ch[1].rlen = (ch[1].rlen+1)"
	line 71, state 186, "printf('Matching R:%d procs to W:%d procs\n',ch[1].rlen,ch[1].wlen)"
	line 74, state 188, "w = 0"
	line 90, state 191, "w_pid = ch[1].wqueue[w].id"
	line 40, state 196, "((proc[r_pid].lock==0))"
	line 40, state 200, "((proc[w_pid].lock==0))"
	line 40, state 206, "((proc[w_pid].lock==0))"
	line 40, state 210, "((proc[r_pid].lock==0))"
	line 101, state 215, "printf('Success for R:%d and W:%d\n',r_pid,w_pid)"
	line 102, state 216, "proc[r_pid].state = SUCCESS"
	line 103, state 217, "proc[w_pid].state = SUCCESS"
	line 105, state 218, "ch[1].rqueue[r].msg = ch[1].wqueue[w].msg"
	line 103, state 219, "ch[1].wqueue[w].msg = 255"
	line 103, state 220, "proc[r_pid].result_ch = 1"
	line 103, state 221, "proc[w_pid].result_ch = 1"
	line 66, state 223, "proc[r_pid].waitX = 1"
	line 66, state 225, "proc[w_pid].waitX = 1"
	line 104, state 226, "r = 3"
	line 46, state 234, "proc[w_pid].lock = 0"
	line 46, state 240, "proc[r_pid].lock = 0"
	line 89, state 245, "r_pid = ch[1].rqueue[r].id"
	line 73, state 255, "((r<ch[1].rlen))"
	line 73, state 255, "else"
	line 81, state 258, "printf('debug: R:%d, W:%d\n',ch[1].rlen,ch[1].wlen)"
	line 70, state 259, "w = 0"
	line 132, state 260, "ch[1].lock = 0"
	line 132, state 261, "printf('Posted read\n')"
	line 129, state 262, "((ch[1].lock==0))"
	line 40, state 282, "((proc[r_pid].lock==0))"
	line 46, state 320, "proc[w_pid].lock = 0"
	line 150, state 392, "(1)"
	line 174, state 407, "i = 0"
	line 178, state 410, "ch[0].wlen = (ch[0].wlen-1)"
	line 179, state 411, "ch[0].wqueue[i].id = ch[0].wqueue[ch[0].wlen].id"
	line 180, state 412, "ch[0].wqueue[i].msg = ch[0].wqueue[ch[0].wlen].msg"
	line 179, state 414, "(1)"
	line 177, state 415, "((ch[0].wqueue[i].id==_pid))"
	line 177, state 415, "else"
	line 175, state 420, "((i<ch[0].wlen))"
	line 175, state 420, "else"
	line 184, state 423, "ch[0].lock = 0"
	line 173, state 424, "((ch[0].lock==0))"
	line 141, state 431, "i = 0"
	line 146, state 435, "printf('HEY:%d\n',ch[1].rqueue[i].msg)"
	line 147, state 436, "result_msg = ch[1].rqueue[i].msg"
	line 149, state 441, "ch[1].rlen = (ch[1].rlen-1)"
	line 150, state 442, "ch[1].rqueue[i].id = ch[1].rqueue[ch[1].rlen].id"
	line 151, state 443, "ch[1].rqueue[i].msg = ch[1].rqueue[ch[1].rlen].msg"
	line 150, state 445, "(1)"
	line 144, state 446, "((ch[1].rqueue[i].id==_pid))"
	line 144, state 446, "else"
	line 142, state 451, "((i<ch[1].rlen))"
	line 142, state 451, "else"
	line 155, state 454, "ch[1].lock = 0"
	line 140, state 455, "((ch[1].lock==0))"
	line 179, state 467, "(1)"
	(84 of 483 states)
unreached in proctype ALTWR
	line 40, state 22, "((proc[r_pid].lock==0))"
	line 46, state 60, "proc[w_pid].lock = 0"
	line 164, state 93, "ch[1].wqueue[ch[1].wlen].id = _pid"
	line 165, state 94, "ch[1].wqueue[ch[1].wlen].msg = 255"
	line 165, state 95, "ch[1].wlen = (ch[1].wlen+1)"
	line 71, state 98, "printf('Matching R:%d procs to W:%d procs\n',ch[1].rlen,ch[1].wlen)"
	line 74, state 100, "w = 0"
	line 90, state 103, "w_pid = ch[1].wqueue[w].id"
	line 40, state 108, "((proc[r_pid].lock==0))"
	line 40, state 112, "((proc[w_pid].lock==0))"
	line 40, state 118, "((proc[w_pid].lock==0))"
	line 40, state 122, "((proc[r_pid].lock==0))"
	line 101, state 127, "printf('Success for R:%d and W:%d\n',r_pid,w_pid)"
	line 102, state 128, "proc[r_pid].state = SUCCESS"
	line 103, state 129, "proc[w_pid].state = SUCCESS"
	line 105, state 130, "ch[1].rqueue[r].msg = ch[1].wqueue[w].msg"
	line 103, state 131, "ch[1].wqueue[w].msg = 255"
	line 103, state 132, "proc[r_pid].result_ch = 1"
	line 103, state 133, "proc[w_pid].result_ch = 1"
	line 66, state 135, "proc[r_pid].waitX = 1"
	line 66, state 137, "proc[w_pid].waitX = 1"
	line 104, state 138, "r = 3"
	line 46, state 146, "proc[w_pid].lock = 0"
	line 46, state 152, "proc[r_pid].lock = 0"
	line 89, state 157, "r_pid = ch[1].rqueue[r].id"
	line 73, state 167, "((r<ch[1].rlen))"
	line 73, state 167, "else"
	line 81, state 170, "printf('debug: R:%d, W:%d\n',ch[1].rlen,ch[1].wlen)"
	line 70, state 171, "w = 0"
	line 166, state 172, "ch[1].lock = 0"
	line 166, state 173, "printf('Posted write\n')"
	line 163, state 174, "((ch[1].lock==0))"
	line 130, state 181, "ch[0].rqueue[ch[0].rlen].id = _pid"
	line 131, state 182, "ch[0].rqueue[ch[0].rlen].msg = 255"
	line 131, state 183, "ch[0].rlen = (ch[0].rlen+1)"
	line 71, state 186, "printf('Matching R:%d procs to W:%d procs\n',ch[0].rlen,ch[0].wlen)"
	line 74, state 188, "w = 0"
	line 90, state 191, "w_pid = ch[0].wqueue[w].id"
	line 40, state 196, "((proc[r_pid].lock==0))"
	line 40, state 200, "((proc[w_pid].lock==0))"
	line 40, state 206, "((proc[w_pid].lock==0))"
	line 40, state 210, "((proc[r_pid].lock==0))"
	line 101, state 215, "printf('Success for R:%d and W:%d\n',r_pid,w_pid)"
	line 102, state 216, "proc[r_pid].state = SUCCESS"
	line 103, state 217, "proc[w_pid].state = SUCCESS"
	line 105, state 218, "ch[0].rqueue[r].msg = ch[0].wqueue[w].msg"
	line 103, state 219, "ch[0].wqueue[w].msg = 255"
	line 103, state 220, "proc[r_pid].result_ch = 0"
	line 103, state 221, "proc[w_pid].result_ch = 0"
	line 66, state 223, "proc[r_pid].waitX = 1"
	line 66, state 225, "proc[w_pid].waitX = 1"
	line 104, state 226, "r = 3"
	line 46, state 234, "proc[w_pid].lock = 0"
	line 46, state 240, "proc[r_pid].lock = 0"
	line 89, state 245, "r_pid = ch[0].rqueue[r].id"
	line 73, state 255, "((r<ch[0].rlen))"
	line 73, state 255, "else"
	line 81, state 258, "printf('debug: R:%d, W:%d\n',ch[0].rlen,ch[0].wlen)"
	line 70, state 259, "w = 0"
	line 132, state 260, "ch[0].lock = 0"
	line 132, state 261, "printf('Posted read\n')"
	line 129, state 262, "((ch[0].lock==0))"
	line 40, state 292, "((proc[w_pid].lock==0))"
	line 46, state 326, "proc[r_pid].lock = 0"
	line 150, state 392, "(1)"
	line 174, state 407, "i = 0"
	line 178, state 410, "ch[1].wlen = (ch[1].wlen-1)"
	line 179, state 411, "ch[1].wqueue[i].id = ch[1].wqueue[ch[1].wlen].id"
	line 180, state 412, "ch[1].wqueue[i].msg = ch[1].wqueue[ch[1].wlen].msg"
	line 179, state 414, "(1)"
	line 177, state 415, "((ch[1].wqueue[i].id==_pid))"
	line 177, state 415, "else"
	line 175, state 420, "((i<ch[1].wlen))"
	line 175, state 420, "else"
	line 184, state 423, "ch[1].lock = 0"
	line 173, state 424, "((ch[1].lock==0))"
	line 141, state 431, "i = 0"
	line 146, state 435, "printf('HEY:%d\n',ch[0].rqueue[i].msg)"
	line 147, state 436, "result_msg = ch[0].rqueue[i].msg"
	line 149, state 441, "ch[0].rlen = (ch[0].rlen-1)"
	line 150, state 442, "ch[0].rqueue[i].id = ch[0].rqueue[ch[0].rlen].id"
	line 151, state 443, "ch[0].rqueue[i].msg = ch[0].rqueue[ch[0].rlen].msg"
	line 150, state 445, "(1)"
	line 144, state 446, "((ch[0].rqueue[i].id==_pid))"
	line 144, state 446, "else"
	line 142, state 451, "((i<ch[0].rlen))"
	line 142, state 451, "else"
	line 155, state 454, "ch[0].lock = 0"
	line 140, state 455, "((ch[0].lock==0))"
	line 179, state 467, "(1)"
	(84 of 483 states)
unreached in proctype :init:
	(0 of 3 states)

pan: elapsed time 0.01 seconds
